{"meta":{"title":"Blog","subtitle":"JerryZRF的Blog","description":"Never give up!","author":"JerryZRF","url":"https://blog.jerryzrf.cf","root":"/"},"pages":[{"title":"关于","date":"2021-07-14T11:57:55.000Z","updated":"2021-07-14T11:58:55.322Z","comments":false,"path":"about/index.html","permalink":"https://blog.jerryzrf.cf/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-14T11:57:53.000Z","updated":"2021-07-14T12:03:44.404Z","comments":false,"path":"categories/index.html","permalink":"https://blog.jerryzrf.cf/categories/index.html","excerpt":"","text":""},{"title":"资源","date":"2021-07-14T11:57:57.000Z","updated":"2021-07-14T12:03:26.702Z","comments":false,"path":"resources/index.html","permalink":"https://blog.jerryzrf.cf/resources/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-14T11:57:54.000Z","updated":"2021-07-14T12:03:13.302Z","comments":false,"path":"tags/index.html","permalink":"https://blog.jerryzrf.cf/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"526小结-附加","slug":"526小结-附加","date":"2022-05-26T12:23:25.000Z","updated":"2022-05-26T13:52:12.506Z","comments":true,"path":"2022/05/26/526小结-附加/","link":"","permalink":"https://blog.jerryzrf.cf/2022/05/26/526%E5%B0%8F%E7%BB%93-%E9%99%84%E5%8A%A0/","excerpt":"","text":"2022-05-26 都内卷是吧，小结写三面是吧，我直接写1500字 五·二六事变 作业解体，八班剧变，和平结束 今天，发生了惨烈的五·二六事变。 只因为一个同学，在昨日的作业记录表中的小结里写道”数学作业很少“，甚至在晚辅的时候无聊到发呆，所以数学老师特别”贴心地“多布置了一张学案作为回家作业。 为什么交给英语老师的作业记录本里记得内容会被数学老师看到啊啊啊啊！ 很明显，肯定是英语老师看到了，准备给我们多布置一点作业，顺便告诉数学老师的。 所以今天的英语作业也特别多（虽然我上午就差不多写完了 所以得出结论：还是物理好 但是做这么多题真的有用吗？（指英语做的题70%是重复的） 我们应该要高效的学习，而不是肤浅的刷题。（内涵某个叫《家校通》的东西，大胆预言一波，这个将会变成暑假作业） SolarTerms嗯，这个东西基本的都写好了。 其实我一开始想用Unreal Engine 5做一个太阳系模型，模拟地球在每一个节气的位置的。但是看了看文件，说要联系生活实际，要实地考察，便放弃了这个想法（实际上是我不会用UE5） 所以就该做Android App了。顺带一说，这个IDEA是我白嫖的，但是我非常不提倡这种做法！！！但是开源的Community版本用用不了Android Studio的功能，所以只好白嫖一下了。 现在的成果的话，因为不太方便放图（懒），就附一个github的链接了，想看成果的可以自己构建。（仅有Android版本，iOS版需要一台Mac，还要学Objective-C，只得以作罢） https://www.github.com/JerryZRF/SolarTerms 嗯，写得很渣。水平有限，又不是不能跑。 下次有空录个视频吧 论内卷内卷是一种奇怪的现象。 有些同学的内卷就是以最快的速度做完老师布置的任务。 有些同学的内卷就是抽空去刷题。 有些同学的内卷是用空闲时间去学习课内外的新知识。 嗯，这是个递进关系。 要先完成任务，在去拓展，再去发展兴趣。 很不巧，我是一个很懒的人。我只做到了1和3（拜托，真的有这么上进的好孩子去刷难题吗，我都躺平了） 哎，我每天写完作业就刷会B站，写写代码了。完全没有动力刷难题，也没有时间刷难题。写代码是真的耗时间，一个小bug改1个小时是日常好吧。大bug还好改，好发现原因；小bug真的是恶心，有时候就是一条语句写得差了点意思，就出现大问题。 其实我在学校里感觉很卷，其实还是为了快点完成作业，回家可以休息。可能我定了很多计划，但是真的就没有动力去执行。 但是，我也已经有了一个大计划！ ——我真的要好好去学JVM底层了！真的很重要，学好了之后思维应该会有很大的提升。至于学完了之后（应该要很久，毕竟也不简单，说不定就烂尾了），学GoLang什么的真的没有动力，哎。 小结说到现在好像也没说今天做了什么。 其实今天真的没做什么，到家后作业写完了，就娱乐了一小会，就8点了。然后加了一个按钮，改了一点点配置文件，确定了AR相机可以跑起来，就结束了。 一回想起来，浪费时间的地方真的很多。 因为模拟器没有摄像头，就用实体机，结果接了数据线没反应，想用adb，结果找不到放哪里了。找了半天，在官网下了一个，结果感觉有没什么用，才用QQ把apk传过去（15mins+） 布局编辑器怪怪的今天，用起来出了点问题。写Activity转跳时有脑子抽筋了，多花了几分钟。（10mins+） 其它都想不起来了，哎，精神状态不佳呀。不过今天Great FireWall很给面子，一次就push成功了 话说我在写完这个之后，应该会找一个CDN把我的blog弄上去，这样访问就会快很多了。","categories":[{"name":"小结","slug":"小结","permalink":"https://blog.jerryzrf.cf/categories/%E5%B0%8F%E7%BB%93/"}],"tags":[{"name":"小结","slug":"小结","permalink":"https://blog.jerryzrf.cf/tags/%E5%B0%8F%E7%BB%93/"}]},{"title":"算法-最短路径长度","slug":"算法-最短路径长度","date":"2021-07-28T02:18:39.000Z","updated":"2021-07-28T03:19:08.712Z","comments":true,"path":"2021/07/28/算法-最短路径长度/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/28/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6/","excerpt":"算法-贪心1 最短路径长度","text":"算法-贪心1 最短路径长度 简介 给定一个n * n的矩阵M，其中 (i, j) 表示 i 到 j 的距离为M[i][j]求start到各个点的最短路径长度 演示 0 999 10 999 30 100999 0 5 999 999 999999 999 0 50 999 999999 999 999 0 999 10999 999 999 20 0 60999 999 999 999 999 0(999表示无路可走) 以0为起点的最短路径长度是0 999 10 50 30 60 演示解析 0：0 -&gt; 0​ 0 + 0 = 0 1：0 -&gt; 1​ 0 + 999 = 999(无路可走) 2：0 -&gt; 2​ 0 + 10 = 10 3：0 -&gt; 2 -&gt; 3 || 0 -&gt; 4 -&gt; 3​ 0 + 10 + 50 = 60 || 0 + 20 + 30 = 50 4：0 -&gt; 4​ 0 + 30 = 30 5：0 -&gt; 2 -&gt; 3 -&gt; 5 || 0 -&gt; 4 -&gt; 3 -&gt; 5​ 0 + 10 + 50 + 10 = 70 || 0 + 20 + 30 + 10 = 60 思路 我们先把start到各点的路径长度当作最短路径长度，再找到其中的最小值Min，计算经过Min后的路径长度，和本来的长度比较，取出最小值. 其中我们还要一个标记向量vis，当 i 为最小值时，vis[i] 为 true，其后就不再更改. 实现12345678910111213141516171819202122232425262728293031323334int FindMinIndex(vector&lt;int&gt; &amp;v, vector&lt;bool&gt; &amp;vis)&#123; int MinIndex = 0; while(vis[MinIndex] == true) //跳过已固定的路径长度 &#123; MinIndex++; &#125; for(int i = MinIndex + 1; i &lt; v.size(); i++) &#123; if(vis[i] == true) //跳过已固定的路径长度 &#123; continue; &#125; if(v[i] &lt; v[MinIndex]) &#123; MinIndex = i; &#125; &#125; return MinIndex;&#125;// Path[i][j]: i到j的路径长度// Length[i]: start到i的最短路径长度void Dijkstra(vector&lt;vector&lt;int&gt;&gt; &amp;Paths, vector&lt;int&gt; &amp;Length, int start)&#123; vector&lt;bool&gt; vis(Paths.size(), false); //已固定标记 vis[start] = true; int MinIndex; Length = Paths[start]; //初始化最短路径长度 for(int i = 1; i &lt; Paths.size(); i++) &#123; MinIndex = FindMinIndex(Length, vis); //start到MinIndex最短 vis[MinIndex] = true; //标记 for(int j = 0; j &lt; Length.size(); j++) &#123; if(vis[j] == true) //跳过已固定的路径长度 &#123; continue; &#125; //更新从start出发的最短路径长度 Length[j] = min(Paths[MinIndex][j] + Length[MinIndex], Length[j]); &#125; &#125;&#125; END 本文就到这里了，接下来你可以自己写一个函数，求出怎么走是最短路径.","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-最长公共子串","slug":"算法-最长公共子串","date":"2021-07-18T11:39:58.000Z","updated":"2022-03-17T07:30:36.962Z","comments":true,"path":"2021/07/18/算法-最长公共子串/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/18/%E7%AE%97%E6%B3%95-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/","excerpt":"算法-字符串1 最长公共子串","text":"算法-字符串1 最长公共子串 简介 在两个字符串中，找到最长公共子串(Longest Common Subsequence)的长度.即最长的相同的一段的长度 演示 字符串A: “abcjerryzrfdef”字符串B: “ajerryzrfbcdefgh” 它们的最长公共子串的长度为8. 演示解析 字符串A: “abcjerryzrfde”字符串B: “ajerryzrfb” 他们的最长公共子串为”jerryzrf”. 实现Version 1 (暴力枚举)暴力枚举yyds 12345678910111213141516171819202122int GetLCSLength(string &amp;strA, string &amp;strB)&#123; int lengthA = strA.length(); int lengthB = strB.length(); int length = 0; //公共子串长度 int MaxLength = 0; //最长公共子串长度 for(int i = 0; i &lt; lengthA; i++) &#123; for(int j = 0; j &lt; lengthB; j++) &#123; while(strA[i] == strB[j] &amp;&amp; i &lt; lengthA &amp;&amp; j &lt; lengthB) //找到公共子序列 &#123; i++; j++; length++; &#125; MaxLength = max(length, MaxLength); //更新最长公共子串长度 length = 0; //公共子串长度归零 &#125; &#125; return MaxLength;&#125; 可以看到这种暴力枚举的性能在大量数据情况下很差，时间复杂度大概为O(lengthA * lengthB)，接下来我们用上另一种算法. Version 2 (数组矩阵) 求最长公共子串长度，就是求字符串A和字符串B中最长重复的地方的长度，于是我们可以摆出字符串A和字符串B，把它们放在矩阵中，相同的地方为true，否则为false.如字符串A: “abcjerryzrfde”字符串B: “ajerryzrfb”&nbsp;&nbsp;&nbsp;a b c &nbsp;j&nbsp;e&nbsp;r&nbsp; r&nbsp; y z r &nbsp;fa 1 0 0 0 0 0 0 0 0 0 0j 0 0 0 1 0 0 0 0 0 0 0e 0 0 0 0 1 0 0 0 0 0 0r 0 0 0 0 0 1 1 0 0 1 1r 0 0 0 0 0 1 1 0 0 1 1y 0 0 0 0 0 0 0 1 0 0 0z 0 0 0 0 0 0 0 0 1 0 0r 0 0 0 0 0 0 0 0 0 1 0f 0 0 0 0 0 0 0 0 0 0 1b 0 1 0 0 0 0 0 0 0 0 0 从中我们可以发现，公共子串就是一条斜线.所以我们可以写一个函数，求出每一条斜线中连续部分的长度，其中最长的长度，即为最长公共子串的长度 当我们计算最长连续斜线长度时，我们就会发现一个问题：如何表示当前计算的是哪一条斜线？这时候我们就把对角线看作 0 ，左下的是负数，右上的是正数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//在(lengthA * lengthB)的矩阵中，获取从 k 开始的斜线长度int GetObliqueLength(bool matrix[][100001], int lengthA, int lengthB, int k)&#123; //初始化 bool ObliqueLine[100001]; //斜线 int cnt = 0; //斜线长度 int x, y; //开始的(x, y)坐标 if (k &lt; 0) //在左下部分 &#123; x = -k; y = 0; &#125; else &#123; //在右上部分或为对角线 x = 0; y = k; &#125; //获取斜线 while (x &lt; lengthA &amp;&amp; y &lt; lengthB) &#123; ObliqueLine[cnt++] = matrix[x++][y++]; &#125; //计算最长连续斜线长度 int length = 0; //连续斜线长度 int MaxLength = 0; //最长连续斜线长度 for (int i = 0; i &lt; cnt; i++) &#123; if (ObliqueLine[i] == false) //不连续 &#123; MaxLength = max(length, MaxLength); //更新最长连续斜线长度 length = 0; //连续斜线长度归零 continue; &#125; length++; //连续斜线长度增加 &#125; return max(length, MaxLength); //返回最长连续斜线长度&#125;//获取最长公共子串的长度//Longest Common Subsequenceint GetLCSLength(string &amp;strA, string &amp;strB)&#123; int lengthA = strA.length(); int lengthB = strB.length(); //转换为矩阵 bool matrix[lengthA][100001]; for (int i = 0; i &lt; lengthA; i++) &#123; for(int j = 0; j &lt; lengthB; j++) &#123; matrix[i][j] = strA[i] == strB[j]; &#125; &#125; //找到最长连续斜线 int max = 0; for (int i = -lengthA + 1; i &lt; lengthB; i++) &#123; int length = GetObliqueLength(matrix, lengthA, lengthB, i); max = (length &gt; max) ? length : max; &#125; return max;&#125; 该版本用的是数组写的，可能有点丑，接下来是一个用vector写的. Version 3 (vector矩阵)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//在(lengthA * lengthB)的矩阵中，获取从 k 开始的斜线长度int GetObliqueLength(vector&lt;vector&lt;bool&gt;&gt; &amp;matrix, int k)&#123; //初始化 vector&lt;bool&gt; ObliqueLine; //斜线 int cnt = 0; //斜线长度 int x, y; //开始的(x, y)坐标 if(k &lt; 0) //在左下部分 &#123; x = -k; y = 0; &#125;else&#123; //在右上部分或为对角线 x = 0; y = k; &#125; //获取斜线 while(x &lt; matrix.size() &amp;&amp; y &lt; matrix[0].size()) &#123; ObliqueLine.push_back(matrix[x++][y++]); &#125; //计算最长连续斜线长度 int length = 0; //连续斜线长度 int MaxLength = 0; //最长连续斜线长度 for(vector&lt;bool&gt;::iterator it = ObliqueLine.begin(); it != ObliqueLine.end(); it++) &#123; if(*it == false) //不连续 &#123; MaxLength = max(length, MaxLength); //更新最长连续斜线长度 length = 0; //连续斜线长度归零 continue; &#125; length++; //连续斜线长度增加 &#125; return max(length, MaxLength); //返回最长连续斜线长度&#125;//获取最长公共子串的长度//Longest Common Subsequenceint GetLCSLength(string &amp;strA, string &amp;strB)&#123; int lengthA = strA.length(); int lengthB = strB.length(); //转换为矩阵 vector&lt;vector&lt;bool&gt;&gt; matrix(lengthA, vector&lt;bool&gt;(lengthB, false)); for(int i = 0; i &lt; lengthA; i++) &#123; for(int j = 0; j &lt; lengthB; j++) &#123; matrix[i][j] = strA[i] == strB[j]; &#125; &#125; //找到最长连续斜线 int max = 0; for(int i = -lengthA + 1; i &lt; lengthB; i++) &#123; int length = GetObliqueLength(matrix, i); max = (length &gt; max) ? length : max; &#125; return max;&#125; 别忘了 1#include &lt;vector&gt; END 本文就到这里了，接下来你可以自己写一个函数，求出最长公共子串和其长度.暴力枚举yyds!","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-排序-堆","slug":"算法-排序-堆","date":"2021-07-18T04:14:52.000Z","updated":"2021-07-18T11:40:25.262Z","comments":true,"path":"2021/07/18/算法-排序-堆/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/18/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E5%A0%86/","excerpt":"算法-排序5 堆排序","text":"算法-排序5 堆排序 特点 不稳定 较难理解(一时的) 简介 堆排序，顾名思义，用”堆”(完全二叉树)来排序. 堆又分两种：小根堆(分支节点小于它的子节点)(降序)、大根堆(分支节点大于它的子节点)(升序). 经过实验得知，完全二叉树的最后一个分支节点是n / 2 - 1. 演示 原始数据(8个)7 4 8 3 2 5 1 6 1234 7 4 8 3 2 5 16 建堆从下至上，依次调整分支节点 i = 3 1234 7 4 8 3 2 5 16 i = 2 1234 7 4 1 3 2 5 86 i = 1 1234 7 2 1 3 4 5 86 i = 0 1234 1 2 5 3 4 5 86 排序(出堆)首尾交换，调整根节点 i = 7 1234 2 3 5 6 4 7 8(1) i = 6 1234 3 4 5 6 8 7 (2)(1) i = 5 1234 4 6 5 7 8 (3) (2)(1) i = 4 1234 5 6 8 7 (4) (3) (2)(1) i = 3 1234 6 7 8 (5) (4) (3) (2)(1) i = 2 1234 7 8 (6) (5) (4) (3) (2)(1) i = 1 1234 8 (7) (6) (5) (4) (3) (2)(1) 至此，数据已经变成有序. 实现123456789101112131415161718192021222324252627282930313233//在有n个节点的堆中调整第k个节点void HeapShift(int array[], int n, int k)&#123; while(k * 2 + 1 &lt; n) //为分支节点(有孩子) &#123; int child = k * 2 + 1; //左右孩子的最小值的下标，默认为左孩子的下标 if(child + 1 &lt; n &amp;&amp; array[child + 1] &lt; array[child]) //有右孩子，且比左孩子小 &#123; child++; //更新左右孩子的最小值的下标为右孩子的下标 &#125; if(array[child] &gt; array[k]) //左右孩子的最小值比父大(调整完毕) &#123; return; //结束 &#125; swap(array[child], array[k]); //交换 k = child; //调整下一个 &#125;&#125;void Sort(int array[], int n)&#123; //建堆：从下至上依次调整分支节点 for(int i = n / 2 - 1; i &gt;= 0; i--) &#123; HeapShift(array, n, i); &#125; //排序(出堆)：首尾交换，调整根节点 for(int i = n - 1; i &gt; 0; i--) &#123; swap(array[0], array[i]); HeapShift(array, i, 0); &#125;&#125; END 堆排序理解起来可能有点困难，需要你多用数据模拟几次. 接下来还有桶、希尔排序等.","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-排序-快速","slug":"算法-排序-快速","date":"2021-07-17T07:20:25.000Z","updated":"2021-07-18T11:40:38.603Z","comments":true,"path":"2021/07/17/算法-排序-快速/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E5%BF%AB%E9%80%9F/","excerpt":"算法-排序4 快速排序","text":"算法-排序4 快速排序 特点 不稳定 平均性能高 简介 快速排序，顾名思义，很快. STL库中的sort()函数用的就是快速排序. 演示 原始数据(8个)X 4 8 3 2 5 1 6基准值 X = 7 第一次处理6 4 8 3 2 5 1 Xi j 第二次处理6 4 X 3 2 5 1 8 i j 第三次处理6 4 1 3 2 5 X 8 i j 第四次处理6 4 1 3 2 5 X 8 ij 放回原位 6 4 1 3 2 5 7 8 演示解析 经过处理，数据变成了两部分。在a[i]左侧的是比它小的数字，右侧的是比它大的数字.我们再将左侧进行处理，右侧进行处理，以此递归，直到左侧下标大于右侧下标，最终数据将变得有序. 实现1234567891011121314151617181920212223242526272829303132333435363738int Part(int array[], int start, int end)&#123; int X = array[start]; while(start &lt; end) &#123; while(array[end] &gt; X &amp;&amp; start &lt; end) //越界检查 &#123; end--; //找到右侧第一个比参考值小的 &#125; if(start &lt; end) //越界检查 &#123; array[start] = array[end]; //交换 start++; &#125; while(array[start] &lt; X &amp;&amp; start &lt; end) //越界检查 &#123; start++; //找到左侧第一个比参考值大的 &#125; if(start &lt; end) //越界检查 &#123; array[end] = array[start]; //交换 end--; &#125; &#125; //循环结束：start == end array[start] = X; return start;&#125;void Sort(int array[], int start, int end)&#123; if(start &gt;= end) //越界检查 return; int part = Part(array, start, end); //分治 Sort(array, start, part - 1); //左半边 Sort(array, part + 1, end); //右半边&#125; END 快速排序是一种性能较高的排序. 递归可能有点难以理解，最好自己拿数据试一试.接下来还有快速、堆、桶排序等.","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-排序-插入","slug":"算法-排序-插入","date":"2021-07-17T05:20:02.000Z","updated":"2021-07-18T11:40:25.999Z","comments":true,"path":"2021/07/17/算法-排序-插入/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E6%8F%92%E5%85%A5/","excerpt":"算法-排序3 插入排序","text":"算法-排序3 插入排序 特点 简单 对少量数据性能较好 稳定 简介 插入排序，顾名思义，把待排序的数据插入到应该在的位置. 演示 原始数据(8个)7 4 8 3 2 5 1 6 第一次排序7 4 8 3 2 5 1 6 第二次排序4 7 8 3 2 5 1 6 第三次排序4 7 8 3 2 5 1 6 第四次排序3 4 7 8 2 5 1 6 第五次排序2 3 4 7 8 5 1 6 第六次排序2 3 4 5 7 8 1 6 第七次排序1 2 3 4 5 7 8 6 第八次排序1 2 3 4 5 6 7 8 演示解析 第 i 次排序，是将a[i]从 i 向前移动 j 个数字，直到a[j]小于a[i]。 实现12345678910void Sort(int array[], int n)&#123; for(int i = 0; i &lt; n; i++) &#123; int j; for(int j = i; j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1]; j--) //当a[j]大于a[j - i]且没越界 swap(array[j], array[j - 1]); //向后移动 array[j - 1] = array[i]; //填充空位 &#125;&#125; END 插入排序依旧是一中较为简单的排序，接下来还有快速、堆、桶排序等。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-排序-选择","slug":"算法-排序-选择","date":"2021-07-17T03:35:11.000Z","updated":"2021-07-18T11:40:34.233Z","comments":true,"path":"2021/07/17/算法-排序-选择/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E9%80%89%E6%8B%A9/","excerpt":"算法-排序2 选择排序","text":"算法-排序2 选择排序 特点 不稳定(你也许没听懂) 较简单(至少我认为) 简介 选择排序，顾名思义，选择一个数，放到相应的位置. 演示 原始数据(8个)7 4 8 3 2 5 1 6 第一次排序1 4 8 3 2 5 7 6 第二次排序1 2 8 3 4 5 7 6 第三次排序1 2 3 8 4 5 7 6 第四次排序1 2 3 4 8 5 7 6 第五次排序1 2 3 4 5 8 7 6 第六次排序1 2 3 4 5 6 7 8 演示解析 从数据变化中我们可以看出，每一次都选择了未排序的子序列中的最小值和当前要排序的值进行交换. 实现1234567891011121314151617181920int FindiMin(int array[], int n, int start) //找到array[start] ~ array[n - 1]中的最小值&#123; int imin = start; for(int i = start + 1; i &lt; n; i++) &#123; if(array[i] &lt; array[imin]) &#123; imin = i; &#125; &#125; return imin;&#125;void Sort(int array[], int n)&#123; for(int i = 0; i &lt; n; i++) &#123; int imin = FindiMin(array, n, i); swap(array[imin], array[i]); &#125;&#125; END 选择排序还是一种比较简单的排序方法，接下来还有插入、快速、堆、桶排序等.","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-排序-冒泡","slug":"算法-排序-冒泡","date":"2021-07-16T08:15:30.000Z","updated":"2021-07-18T12:31:48.978Z","comments":true,"path":"2021/07/16/算法-排序-冒泡/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/16/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1/","excerpt":"算法-排序前言 有人可能会说，STL库中不是有sort函数吗，为什么还有学排序呢？因为排序的基本算法还有很多功能，如快速排序的求第k小(大)的数、插入排序的一元多项式等等。 1 冒泡排序","text":"算法-排序前言 有人可能会说，STL库中不是有sort函数吗，为什么还有学排序呢？因为排序的基本算法还有很多功能，如快速排序的求第k小(大)的数、插入排序的一元多项式等等。 1 冒泡排序 特点 简单(至少我个人认为) 稳定(你也许没听懂) 简介 冒泡排序，顾名思义，小的数据像泡泡一样向上(前)浮(移动). 演示 原始数据(8个)7 4 8 3 2 5 1 6 第一次排序4 7 3 2 5 1 6 8 第二次排序4 3 2 5 1 6 7 8 第三次排序3 2 4 1 5 6 7 8 第四次排序2 3 1 4 5 6 7 8 第五次排序2 1 3 4 5 6 7 8 第六次排序1 2 3 4 5 6 7 8 演示解析 从数据变化中我们可以看出，小的数据一直再向前走，大的数据一直在向后走，就像泡泡一样，向上浮。 实现Version 1 基本版本12345678910111213void Sort(int array[], int num)&#123; for(int i = 0; i &lt; num; i++) //需要走num遍排序 &#123; for(int j = 0; j &lt; num - 1; j++) //从0比较到num-1 &#123; if(array[j] &gt; array[j + 1]) //和后面一个数比较 &#123; swap(array[j], array[j + 1]); //交换 &#125; &#125; &#125;&#125; 在这个版本中，我们可以看到需要走num遍排序，时间复杂度是O(num^2)。而像演示一样的情况中，后面两次其实是不用走到，所以我们就要一个判断，判断数据是否已经有序。 Version 2 改进版本123456789101112131415161718void Sort(int array[], int num)&#123; bool flag; for(int i = 0; i &lt; num; i++) &#123; flag = true; //是否有序 for(int j = 0; j &lt; num - 1; j++) &#123; if(array[j] &gt; array[j + 1]) //更小 &#123; swap(array[j], array[j + 1]); //交换 flag = false; //依旧无序 &#125; &#125; if(flag == true) //已经有序 break; //跳出循环 &#125;&#125; 有了有序特判，算法的性能有了小幅提高。 END 冒泡排序还是一种比较简单的排序方法，接下来还有选择、插入、快速、堆、桶排序等。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"第一篇博文","slug":"第一篇博文","date":"2021-07-14T13:03:05.000Z","updated":"2021-07-17T10:39:56.471Z","comments":true,"path":"2021/07/14/第一篇博文/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/","excerpt":"","text":"第一篇博文Hello WorldJerryZRF 的 Blog 的第一篇博文发布于 2021-7-14 21:05","categories":[{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%A5%E5%BF%97/"},{"name":"时刻","slug":"时刻","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%B6%E5%88%BB/"}]}],"categories":[{"name":"小结","slug":"小结","permalink":"https://blog.jerryzrf.cf/categories/%E5%B0%8F%E7%BB%93/"},{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"},{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"小结","slug":"小结","permalink":"https://blog.jerryzrf.cf/tags/%E5%B0%8F%E7%BB%93/"},{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"},{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%A5%E5%BF%97/"},{"name":"时刻","slug":"时刻","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%B6%E5%88%BB/"}]}