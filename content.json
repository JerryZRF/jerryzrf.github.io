{"meta":{"title":"Blog","subtitle":"JerryZRF的Blog","description":"Never Give Up!","author":"JerryZRF","url":"https://blog.jerryzrf.cf","root":"/"},"pages":[{"title":"关于","date":"2021-07-14T11:57:55.000Z","updated":"2021-07-14T11:58:55.322Z","comments":false,"path":"about/index.html","permalink":"https://blog.jerryzrf.cf/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-14T11:57:53.000Z","updated":"2021-07-14T12:03:44.404Z","comments":false,"path":"categories/index.html","permalink":"https://blog.jerryzrf.cf/categories/index.html","excerpt":"","text":""},{"title":"资源","date":"2021-07-14T11:57:57.000Z","updated":"2021-07-14T12:03:26.702Z","comments":false,"path":"resources/index.html","permalink":"https://blog.jerryzrf.cf/resources/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-14T11:57:54.000Z","updated":"2021-07-14T12:03:13.302Z","comments":false,"path":"tags/index.html","permalink":"https://blog.jerryzrf.cf/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基本算法-排序-堆","slug":"基本算法-排序-堆","date":"2021-07-18T04:14:52.000Z","updated":"2021-07-18T05:07:09.100Z","comments":true,"path":"2021/07/18/基本算法-排序-堆/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/18/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E5%A0%86/","excerpt":"基本算法-排序5 堆排序","text":"基本算法-排序5 堆排序 特点 不稳定 较难理解(一时的) 简介 堆排序，顾名思义，用”堆”(完全二叉树)来排序. 堆又分两种：小根堆(分支节点小于它的子节点)(降序)、大根堆(分支节点大于它的子节点)(升序). 经过实验得知，完全二叉树的最后一个分支节点是n / 2 - 1. 演示 原始数据(8个)7 4 8 3 2 5 1 6 1234 7 4 8 3 2 5 16 1 建堆从下至上，依次调整分支节点 i = 3 1234 7 4 8 3 2 5 16 i = 2 1234 7 4 1 3 2 5 86 i = 1 1234 7 2 1 3 4 5 86 i = 0 1234 1 2 5 3 4 7 86 2 排序(出堆)首尾交换，调整根节点 i = 7 1234 2 3 5 6 4 7 8(1) i = 6 1234 3 4 5 6 8 7 (2)(1) i = 5 1234 4 6 5 7 8 (3) (2)(1) i = 4 1234 5 6 8 7 (4) (3) (2)(1) i = 3 1234 6 7 8 (5) (4) (3) (2)(1) i = 2 1234 7 8 (6) (5) (4) (3) (2)(1) i = 1 1234 8 (7) (6) (5) (4) (3) (2)(1) 至此，数据已经变成有序. 实现123456789101112131415161718192021222324252627282930313233//在有n个节点的堆中调整第k个节点void HeapShift(int array[], int n, int k)&#123; while(k * 2 + 1 &lt; n) //为分支节点(有孩子) &#123; int child = k * 2 + 1; //左右孩子的最小值的下标，默认为左孩子的下标 if(child + 1 &lt; n &amp;&amp; array[child + 1] &lt; array[child]) //有右孩子，且比左孩子小 &#123; child++; //更新左右孩子的最小值的下标为右孩子的下标 &#125; if(array[child] &gt; array[k]) //左右孩子的最小值比父大(调整完毕) &#123; return; //结束 &#125; swap(array[child], array[k]); //交换 k = child; //调整下一个 &#125;&#125;void Sort(int array[], int n)&#123; //建堆：从下至上依次调整分支节点 for(int i = n / 2 - 1; i &gt;= 0; i--) &#123; HeapShift(array, n, i); &#125; //排序(出堆)：首尾交换，调整根节点 for(int i = n - 1; i &gt; 0; i--) &#123; swap(array[0], array[i]); HeapShift(array, i, 0); &#125;&#125; END 堆排序理解起来可能有点困难，需要你多用数据模拟几次. 接下来还有桶、希尔排序等.","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"基本算法-排序-快速","slug":"基本算法-排序-快速","date":"2021-07-17T07:20:25.000Z","updated":"2021-07-18T05:11:55.984Z","comments":true,"path":"2021/07/17/基本算法-排序-快速/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/17/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E5%BF%AB%E9%80%9F/","excerpt":"基本算法-排序4 快速排序","text":"基本算法-排序4 快速排序 特点 不稳定 平均性能高 简介 快速排序，顾名思义，很快. STL库中的sort()函数用的就是快速排序. 演示 原始数据(8个)X 4 8 3 2 5 1 6基准值 X = 7 第一次处理6 4 8 3 2 5 1 Xi j 第二次处理6 4 X 3 2 5 1 8 i j 第三次处理6 4 1 3 2 5 X 8 i j 第四次处理6 4 1 3 2 5 X 8 ij 放回原位 6 4 1 3 2 5 7 8 演示解析 经过处理，数据变成了两部分。在a[i]左侧的是比它小的数字，右侧的是比它大的数字.我们再将左侧进行处理，右侧进行处理，以此递归，直到左侧下标大于右侧下标，最终数据将变得有序. 实现1234567891011121314151617181920212223242526272829303132333435363738int Part(int array[], int start, int end)&#123; int X = array[start]; while(start &lt; end) &#123; while(array[end] &gt; X &amp;&amp; start &lt; end) //越界检查 &#123; end--; //找到右侧第一个比参考值小的 &#125; if(start &lt; end) //越界检查 &#123; array[start] = array[end]; //交换 start++; &#125; while(array[start] &lt; X &amp;&amp; start &lt; end) //越界检查 &#123; start++; //找到左侧第一个比参考值大的 &#125; if(start &lt; end) //越界检查 &#123; array[end] = array[start]; //交换 end--; &#125; &#125; //循环结束：start == end array[start] = X; return start;&#125;void Sort(int array[], int start, int end)&#123; if(start &gt;= end) //越界检查 return; int part = Part(array, start, end); //分治 Sort(array, start, part - 1); //左半边 Sort(array, part + 1, end); //右半边&#125; END 快速排序是一种性能较高的排序. 递归可能有点难以理解，最好自己拿数据试一试.接下来还有快速、堆、桶排序等.","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"基本算法-排序-插入","slug":"基本算法-排序-插入","date":"2021-07-17T05:20:02.000Z","updated":"2021-07-18T05:12:46.030Z","comments":true,"path":"2021/07/17/基本算法-排序-插入/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/17/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E6%8F%92%E5%85%A5/","excerpt":"基本算法-排序3 插入排序","text":"基本算法-排序3 插入排序 特点 简单 对少量数据性能较好 稳定 简介 插入排序，顾名思义，把待排序的数据插入到应该在的位置. 演示 原始数据(8个)7 4 8 3 2 5 1 6 第一次排序7 4 8 3 2 5 1 6 第二次排序4 7 8 3 2 5 1 6 第三次排序4 7 8 3 2 5 1 6 第四次排序3 4 7 8 2 5 1 6 第五次排序2 3 4 7 8 5 1 6 第六次排序2 3 4 5 7 8 1 6 第七次排序1 2 3 4 5 7 8 6 第八次排序1 2 3 4 5 6 7 8 演示解析 第 i 次排序，是将a[i]从 i 向前移动 j 个数字，直到a[j]小于a[i]。 实现12345678910void Sort(int array[], int n)&#123; for(int i = 0; i &lt; n; i++) &#123; int j; for(int j = i; j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1]; j--) //当a[j]大于a[j - i]且没越界 swap(array[j], array[j - 1]); //向后移动 array[j - 1] = array[i]; //填充空位 &#125;&#125; END 插入排序依旧是一中较为简单的排序，接下来还有快速、堆、桶排序等。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"基本算法-排序-选择","slug":"基本算法-排序-选择","date":"2021-07-17T03:35:11.000Z","updated":"2021-07-18T05:08:25.748Z","comments":true,"path":"2021/07/17/基本算法-排序-选择/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/17/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E9%80%89%E6%8B%A9/","excerpt":"基本算法-排序2 选择排序","text":"基本算法-排序2 选择排序 特点 不稳定(你也许没听懂) 较简单(至少我认为) 简介 选择排序，顾名思义，选择一个数，放到相应的位置. 演示 原始数据(8个)7 4 8 3 2 5 1 6 第一次排序1 4 8 3 2 5 7 6 第二次排序1 2 8 3 4 5 7 6 第三次排序1 2 3 8 4 5 7 6 第四次排序1 2 3 4 8 5 7 6 第五次排序1 2 3 4 5 8 7 6 第六次排序1 2 3 4 5 6 7 8 演示解析 从数据变化中我们可以看出，每一次都选择了未排序的子序列中的最小值和当前要排序的值进行交换. 实现1234567891011121314151617181920int FindiMin(int array[], int n, int start) //找到array[start] ~ array[n - 1]中的最小值&#123; int imin = start; for(int i = start + 1; i &lt; n; i++) &#123; if(array[i] &lt; array[imin]) &#123; imin = i; &#125; &#125; return imin;&#125;void Sort(int array[], int n)&#123; for(int i = 0; i &lt; n; i++) &#123; int imin = FindiMin(array, n, i); swap(array[imin], array[i]); &#125;&#125; END 选择排序还是一种比较简单的排序方法，接下来还有插入、快速、堆、桶排序等.","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"基本算法-排序-冒泡","slug":"基本算法-排序-冒泡","date":"2021-07-16T08:15:30.000Z","updated":"2021-07-18T05:10:28.845Z","comments":true,"path":"2021/07/16/基本算法-排序-冒泡/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/16/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1/","excerpt":"基本算法-排序前言 有人可能会说，STL库中不是有sort函数吗，为什么还有学排序呢？因为排序的基本算法还有很多功能，如快速排序的求第k小(大)的数、插入排序的一元多项式等等。 1 冒泡排序","text":"基本算法-排序前言 有人可能会说，STL库中不是有sort函数吗，为什么还有学排序呢？因为排序的基本算法还有很多功能，如快速排序的求第k小(大)的数、插入排序的一元多项式等等。 1 冒泡排序 特点 简单(至少我个人认为) 稳定(你也许没听懂) 简介 冒泡排序，顾名思义，小的数据像泡泡一样向上(前)浮(移动). 演示 原始数据(8个)7 4 8 3 2 5 1 6 第一次排序4 7 3 2 5 1 6 8 第二次排序4 3 2 5 1 6 7 8 第三次排序3 2 4 1 5 6 7 8 第四次排序2 3 1 4 5 6 7 8 第五次排序2 1 3 4 5 6 7 8 第六次排序1 2 3 4 5 6 7 8 演示解析 从数据变化中我们可以看出，小的数据一直再向前走，大的数据一直在向后走，就像泡泡一样，向上浮。 实现Version 1 基本版本12345678910111213void Sort(int array[], int num)&#123; for(int i = 0; i &lt; num; i++) //需要走num遍排序 &#123; for(int j = 0; j &lt; num - 1; j++) //从0比较到num-1 &#123; if(array[j] &gt; array[j + 1]) //和后面一个数比较 &#123; swap(array[j], array[j + 1]); //交换 &#125; &#125; &#125;&#125; 在这个版本中，我们可以看到需要走num遍排序，时间复杂度是O(num^2)。而像演示一样的情况中，后面两次其实是不用走到，所以我们就要一个判断，判断数据是否已经有序。 Version 2 改进版本123456789101112131415161718void Sort(int array[], int num)&#123; bool flag; for(int i = 0; i &lt; num; i++) &#123; flag = true; //是否有序 for(int j = 0; j &lt; num - 1; j++) &#123; if(array[j] &gt; array[j + 1]) //更小 &#123; swap(array[j], array[j + 1]); //交换 flag = false; //依旧无序 &#125; &#125; if(flag == true) //已经有序 break; //跳出循环 &#125;&#125; 有了有序特判，算法的性能有了小幅提高。 END 冒泡排序还是一种比较简单的排序方法，接下来还有选择、插入、快速、堆、桶排序等。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"第一篇博文","slug":"第一篇博文","date":"2021-07-14T13:03:05.000Z","updated":"2021-07-17T10:39:56.471Z","comments":true,"path":"2021/07/14/第一篇博文/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/","excerpt":"","text":"第一篇博文Hello WorldJerryZRF 的 Blog 的第一篇博文发布于 2021-7-14 21:05","categories":[{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%A5%E5%BF%97/"},{"name":"时刻","slug":"时刻","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%B6%E5%88%BB/"}]}],"categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"},{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"},{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%A5%E5%BF%97/"},{"name":"时刻","slug":"时刻","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%B6%E5%88%BB/"}]}