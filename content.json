{"meta":{"title":"Blog","subtitle":"JerryZRF的Blog","description":"Never Give Up!","author":"JerryZRF","url":"https://blog.jerryzrf.cf","root":"/"},"pages":[{"title":"关于","date":"2021-07-14T11:57:55.000Z","updated":"2021-07-14T11:58:55.322Z","comments":false,"path":"about/index.html","permalink":"https://blog.jerryzrf.cf/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-14T11:57:53.000Z","updated":"2021-07-14T12:03:44.404Z","comments":false,"path":"categories/index.html","permalink":"https://blog.jerryzrf.cf/categories/index.html","excerpt":"","text":""},{"title":"资源","date":"2021-07-14T11:57:57.000Z","updated":"2021-07-14T12:03:26.702Z","comments":false,"path":"resources/index.html","permalink":"https://blog.jerryzrf.cf/resources/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-14T11:57:54.000Z","updated":"2021-07-14T12:03:13.302Z","comments":false,"path":"tags/index.html","permalink":"https://blog.jerryzrf.cf/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基本算法-排序-插入","slug":"基本算法-排序-快速","date":"2021-07-17T07:20:25.000Z","updated":"2021-07-17T07:50:10.247Z","comments":true,"path":"2021/07/17/基本算法-排序-快速/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/17/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E5%BF%AB%E9%80%9F/","excerpt":"","text":"基本算法-排序4 快速排序特点 不稳定 平均性能高 演示 原始数据(8个)X 4 8 3 2 5 1 6基准值 X = 7 第一次处理6 4 8 3 2 5 1 Xi j 第二次处理6 4 X 3 2 5 1 8 i j 第三次处理6 4 1 3 2 5 X 8 i j 第四次处理6 4 1 3 2 5 X 8 ij 放回原位 6 4 1 3 2 5 7 8 演示解析 经过处理，数据变成了两部分。在a[i]左侧的是比它小的数字，右侧的是比它大的数字我们再将左侧进行处理，右侧进行处理，以此递归，直到左侧下标大于右侧下标，最终数据将变得有序 实现1234567891011121314151617181920212223242526272829303132333435363738int Part(int array[], int start, int end)&#123; int X = array[start]; while(start &lt; end) &#123; while(array[end] &gt; X &amp;&amp; start &lt; end) //越界检查 &#123; end--; //找到右侧第一个比参考值小的 &#125; if(start &lt; end) //越界检查 &#123; array[start] = array[end]; //交换 start++; &#125; while(array[start] &lt; X &amp;&amp; start &lt; end) //越界检查 &#123; start++; //找到左侧第一个比参考值大的 &#125; if(start &lt; end) //越界检查 &#123; array[end] = array[start]; //交换 end--; &#125; &#125; //循环结束：start == end array[start] = X; return start;&#125;void Sort(int array[], int start, int end)&#123; if(start &gt;= end) //越界检查 return; int part = Part(array, start, end); //分治 Sort(array, start, part - 1); //左半边 Sort(array, part + 1, end); //右半边&#125; END 快速排序是一种性能较高的排序。递归可能有点难以理解，最好自己拿数据试一试。接下来还有快速、堆、桶排序等。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"基本算法-排序-插入","slug":"基本算法-排序-插入","date":"2021-07-17T05:20:02.000Z","updated":"2021-07-17T06:49:06.631Z","comments":true,"path":"2021/07/17/基本算法-排序-插入/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/17/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E6%8F%92%E5%85%A5/","excerpt":"","text":"基本算法-排序3 插入排序特点 简单 对少量数据性能较好 稳定 演示 原始数据(8个)7 4 8 3 2 5 1 6 第一次排序7 4 8 3 2 5 1 6 第二次排序4 7 8 3 2 5 1 6 第三次排序4 7 8 3 2 5 1 6 第四次排序3 4 7 8 2 5 1 6 第五次排序2 3 4 7 8 5 1 6 第六次排序2 3 4 5 7 8 1 6 第七次排序1 2 3 4 5 7 8 6 第八次排序1 2 3 4 5 6 7 8 演示解析 第 i 次排序，是将a[i]从 i 向前移动 j 个数字，直到a[j]小于a[i]。 实现12345678910void Sort(int array[], int n)&#123; for(int i = 0; i &lt; n; i++) &#123; int j; for(int j = i; j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1]; j--) //当a[j]大于a[j - i]且没越界 swap(array[j], array[j - 1]); //向后移动 array[j - 1] = array[i]; //填充空位 &#125;&#125; END 插入排序依旧是一中较为简单的排序，接下来还有快速、堆、桶排序等。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"基本算法-排序-选择","slug":"基本算法-排序-选择","date":"2021-07-17T03:35:11.000Z","updated":"2021-07-17T06:49:22.216Z","comments":true,"path":"2021/07/17/基本算法-排序-选择/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/17/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E9%80%89%E6%8B%A9/","excerpt":"","text":"基本算法-排序2 选择排序特点 不稳定(你也许没听懂) 较简单(至少我认为) 演示 原始数据(8个)7 4 8 3 2 5 1 6 第一次排序1 4 8 3 2 5 7 6 第二次排序1 2 8 3 4 5 7 6 第三次排序1 2 3 8 4 5 7 6 第四次排序1 2 3 4 8 5 7 6 第五次排序1 2 3 4 5 8 7 6 第六次排序1 2 3 4 5 6 7 8 演示解析 从数据变化中我们可以看出，每一次都选择了未排序的子序列中的最小值和当前要排序的值进行交换。 实现1234567891011121314151617181920int FindiMin(int array[], int n, int start) //找到array[start] ~ array[n - 1]中的最小值&#123; int imin = start; for(int i = start + 1; i &lt; n; i++) &#123; if(array[i] &lt; array[imin]) &#123; imin = i; &#125; &#125; return imin;&#125;void Sort(int array[], int n)&#123; for(int i = 0; i &lt; n; i++) &#123; int imin = FindiMin(array, n, i); swap(array[imin], array[i]); &#125;&#125; END 选择排序还是一种比较简单的排序方法，接下来还有插入、快速、堆、桶排序等","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"基本算法-排序-冒泡","slug":"基本算法-排序-冒泡","date":"2021-07-16T08:15:30.000Z","updated":"2021-07-17T06:49:11.929Z","comments":true,"path":"2021/07/16/基本算法-排序-冒泡/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/16/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1/","excerpt":"","text":"基本算法-排序前言 有人可能会说，STL库中不是有sort函数吗，为什么还有学排序呢？ 因为排序的基本算法还有很多功能，如快速排序的求第k小(大)的数、插入排序的一元多项式等等。 1 冒泡排序特点 简单(至少我个人认为) 稳定(你也许没听懂) 演示 原始数据(8个)7 4 8 3 2 5 1 6 第一次排序4 7 3 2 5 1 6 8 第二次排序4 3 2 5 1 6 7 8 第三次排序3 2 4 1 5 6 7 8 第四次排序2 3 1 4 5 6 7 8 第五次排序2 1 3 4 5 6 7 8 第六次排序1 2 3 4 5 6 7 8 演示解析 从数据变化中我们可以看出，小的数据一直再向前走，大的数据一直在向后走，就像泡泡一样，向上浮。 实现Version 1 基本版本12345678910111213void Sort(int array[], int num)&#123; for(int i = 0; i &lt; num; i++) //需要走num遍排序 &#123; for(int j = 0; j &lt; num - 1; j++) //从0比较到num-1 &#123; if(array[j] &gt; array[j + 1]) //和后面一个数比较 &#123; swap(array[j], array[j + 1]); //交换 &#125; &#125; &#125;&#125; 在这个版本中，我们可以看到需要走num遍排序，时间复杂度是O(num^2)。而像演示一样的情况中，后面两次其实是不用走到，所以我们就要一个判断，判断数据是否已经有序。 Version 2 改进版本123456789101112131415161718void Sort(int array[], int num)&#123; bool flag; for(int i = 0; i &lt; num; i++) &#123; flag = true; //是否有序 for(int j = 0; j &lt; num - 1; j++) &#123; if(array[j] &gt; array[j + 1]) &#123; swap(array[j], array[j + 1]); flag = false; &#125; &#125; if(flag == true) //已经有序 break; //跳出循环 &#125;&#125; 有了有序特判，算法的性能有了小幅提高。 END 冒泡排序还是一种比较简单的排序方法，接下来还有选择、插入、快速、堆、桶排序等。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"第一篇博文","slug":"第一篇博文","date":"2021-07-14T13:03:05.000Z","updated":"2021-07-15T10:20:04.086Z","comments":true,"path":"2021/07/14/第一篇博文/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/","excerpt":"","text":"第一篇博文Hello WorldJerryZRF 的 Blog 的第一篇博文发布于 2021-7-14 21:05","categories":[{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%A5%E5%BF%97/"},{"name":"时刻","slug":"时刻","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%B6%E5%88%BB/"}]}],"categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"},{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"},{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%A5%E5%BF%97/"},{"name":"时刻","slug":"时刻","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%B6%E5%88%BB/"}]}