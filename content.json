{"meta":{"title":"Blog","subtitle":"JerryZRF的Blog","description":"Never Give Up!","author":"JerryZRF","url":"https://blog.jerryzrf.cf","root":"/"},"pages":[{"title":"关于","date":"2021-07-14T11:57:55.000Z","updated":"2021-07-14T11:58:55.322Z","comments":false,"path":"about/index.html","permalink":"https://blog.jerryzrf.cf/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-14T11:57:53.000Z","updated":"2021-07-14T12:03:44.404Z","comments":false,"path":"categories/index.html","permalink":"https://blog.jerryzrf.cf/categories/index.html","excerpt":"","text":""},{"title":"资源","date":"2021-07-14T11:57:57.000Z","updated":"2021-07-14T12:03:26.702Z","comments":false,"path":"resources/index.html","permalink":"https://blog.jerryzrf.cf/resources/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-14T11:57:54.000Z","updated":"2021-07-14T12:03:13.302Z","comments":false,"path":"tags/index.html","permalink":"https://blog.jerryzrf.cf/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"算法-最长公共子串","slug":"算法-最长公共子串","date":"2021-07-18T11:39:58.000Z","updated":"2021-07-19T10:37:07.598Z","comments":true,"path":"2021/07/18/算法-最长公共子串/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/18/%E7%AE%97%E6%B3%95-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/","excerpt":"算法-字符串1 最长公共子串","text":"算法-字符串1 最长公共子串 简介 在两个字符串中，找到最长公共子串(Longest Common Subsequence)的长度.即最长的相同的一段的长度 演示 字符串A: “abcjerryzrfdef”字符串B: “ajerryzrfbcdefgh” 它们的最长公共子串的长度为8. 演示解析 字符串A: “abcjerryzrfde”字符串B: “ajerryzrfb” 他们的最长公共子串为”jerryzrf”. 实现Version 1 (暴力枚举)暴力枚举yyds 12345678910111213141516171819202122int GetLCSLength(string &amp;strA, string &amp;strB)&#123; int lengthA = strA.length(); int lengthB = strB.length(); int length = 0; //公共子串长度 int MaxLength = 0; //最长公共子串长度 for(int i = 0; i &lt; lengthA; i++) &#123; for(int j = 0; j &lt; lengthB; j++) &#123; while(strA[i] == strB[j] &amp;&amp; i &lt; lengthA &amp;&amp; j &lt; lengthB) //找到公共子序列 &#123; i++; j++; length++; &#125; MaxLength = max(length, MaxLength); //更新最长公共子串长度 length = 0; //公共子串长度归零 &#125; &#125; return MaxLength;&#125; 可以看到这种暴力枚举的性能在大量数据情况下很差，时间复杂度大概为O(lengthA * lengthB)，接下来我们用上另一种算法. Version 2 (数组矩阵) 求最长公共子串长度，就是求字符串A和字符串B中最长重复的地方的长度，于是我们可以摆出字符串A和字符串B，把它们放在矩阵中，相同的地方为true，否则为false.如字符串A: “abcjerryzrfde”字符串B: “ajerryzrfb”&nbsp;&nbsp;&nbsp;a b c &nbsp;j&nbsp;e&nbsp;r&nbsp; r&nbsp; y z r &nbsp;fa 1 0 0 0 0 0 0 0 0 0 0j 0 0 0 1 0 0 0 0 0 0 0e 0 0 0 0 1 0 0 0 0 0 0r 0 0 0 0 0 1 1 0 0 1 1r 0 0 0 0 0 1 1 0 0 1 1y 0 0 0 0 0 0 0 1 0 0 0z 0 0 0 0 0 0 0 0 1 0 0r 0 0 0 0 0 0 0 0 0 1 0f 0 0 0 0 0 0 0 0 0 0 1b 0 1 0 0 0 0 0 0 0 0 0 从中我们可以发现，公共子串就是一条斜线.所以我们可以写一个函数，求出每一条斜线中连续部分的长度，其中最长的长度，即为最长公共子串的长度 当我们计算最长连续斜线长度时，我们就会发现一个问题：如何表示当前计算的是哪一条斜线？这时候我们就把对角线看作 0 ，左下的是负数，右上的是正数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//在(lengthA * lengthB)的矩阵中，获取从 k 开始的斜线长度int GetObliqueLength(bool matrix[][100001], int lengthA, int lengthB, int k)&#123; //初始化 bool ObliqueLine[100001]; //斜线 int cnt = 0; //斜线长度 int x, y; //开始的(x, y)坐标 if(k &lt; 0) //在左下部分 &#123; x = -k; y = 0; &#125;else&#123; //在右上部分或为对角线 x = 0; y = k; &#125; //获取斜线 while(x &lt; lengthA &amp;&amp; y &lt; lengthB) &#123; ObliqueLine[cnt++] = matrix[x++][y++]; &#125; //计算最长连续斜线长度 int length = 0; //连续斜线长度 int MaxLength = 0; //最长连续斜线长度 for(int i = 0; i &lt; cnt; i++) &#123; if(ObliqueLine[i] == false) //不连续 &#123; MaxLength = max(length, MaxLength); //更新最长连续斜线长度 length = 0; //连续斜线长度归零 continue; &#125; length++; //连续斜线长度增加 &#125; return max(length, MaxLength); //返回最长连续斜线长度&#125;//获取最长公共子串的长度//Longest Common Subsequenceint GetLCSLength(string &amp;strA, string &amp;strB)&#123; int lengthA = strA.length(); int lengthB = strB.length(); //转换为矩阵 bool matrix[lengthA][100001]; for(int i = 0; i &lt; lengthA; i++) &#123; for(int j = 0; j &lt; lengthB; j++) &#123; matrix[i][j] = strA[i] == strB[j]; &#125; &#125; //找到最长连续斜线 int max = 0; for(int i = -lengthA + 1; i &lt; lengthB; i++) &#123; int length = GetObliqueLength(matrix, lengthA, lengthB, i); max = (length &gt; max) ? length : max; &#125; return max;&#125; 该版本用的是数组写的，可能有点丑，接下来是一个用vector写的. Version 3 (vector矩阵)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//在(lengthA * lengthB)的矩阵中，获取从 k 开始的斜线长度int GetObliqueLength(vector&lt;vector&lt;bool&gt;&gt; &amp;matrix, int k)&#123; //初始化 vector&lt;bool&gt; ObliqueLine; //斜线 int cnt = 0; //斜线长度 int x, y; //开始的(x, y)坐标 if(k &lt; 0) //在左下部分 &#123; x = -k; y = 0; &#125;else&#123; //在右上部分或为对角线 x = 0; y = k; &#125; //获取斜线 while(x &lt; matrix.size() &amp;&amp; y &lt; matrix[0].size()) &#123; ObliqueLine.push_back(matrix[x++][y++]); &#125; //计算最长连续斜线长度 int length = 0; //连续斜线长度 int MaxLength = 0; //最长连续斜线长度 for(vector&lt;bool&gt;::iterator it = ObliqueLine.begin(); it != ObliqueLine.end(); it++) &#123; if(*it == false) //不连续 &#123; MaxLength = max(length, MaxLength); //更新最长连续斜线长度 length = 0; //连续斜线长度归零 continue; &#125; length++; //连续斜线长度增加 &#125; return max(length, MaxLength); //返回最长连续斜线长度&#125;//获取最长公共子串的长度//Longest Common Subsequenceint GetLCSLength(string &amp;strA, string &amp;strB)&#123; int lengthA = strA.length(); int lengthB = strB.length(); //转换为矩阵 vector&lt;vector&lt;bool&gt;&gt; matrix(lengthA, vector&lt;bool&gt;(lengthB, false)); for(int i = 0; i &lt; lengthA; i++) &#123; for(int j = 0; j &lt; lengthB; j++) &#123; matrix[i][j] = strA[i] == strB[j]; &#125; &#125; //找到最长连续斜线 int max = 0; for(int i = -lengthA + 1; i &lt; lengthB; i++) &#123; int length = GetObliqueLength(matrix, i); max = (length &gt; max) ? length : max; &#125; return max;&#125; 别忘了 1#include &lt;vector&gt; END 本文就到这里了，接下来你可以自己写一个函数，求出最长公共子串和其长度.暴力枚举yyds!","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-排序-堆","slug":"算法-排序-堆","date":"2021-07-18T04:14:52.000Z","updated":"2021-07-18T11:40:25.262Z","comments":true,"path":"2021/07/18/算法-排序-堆/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/18/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E5%A0%86/","excerpt":"算法-排序5 堆排序","text":"算法-排序5 堆排序 特点 不稳定 较难理解(一时的) 简介 堆排序，顾名思义，用”堆”(完全二叉树)来排序. 堆又分两种：小根堆(分支节点小于它的子节点)(降序)、大根堆(分支节点大于它的子节点)(升序). 经过实验得知，完全二叉树的最后一个分支节点是n / 2 - 1. 演示 原始数据(8个)7 4 8 3 2 5 1 6 1234 7 4 8 3 2 5 16 建堆从下至上，依次调整分支节点 i = 3 1234 7 4 8 3 2 5 16 i = 2 1234 7 4 1 3 2 5 86 i = 1 1234 7 2 1 3 4 5 86 i = 0 1234 1 2 5 3 4 5 86 排序(出堆)首尾交换，调整根节点 i = 7 1234 2 3 5 6 4 7 8(1) i = 6 1234 3 4 5 6 8 7 (2)(1) i = 5 1234 4 6 5 7 8 (3) (2)(1) i = 4 1234 5 6 8 7 (4) (3) (2)(1) i = 3 1234 6 7 8 (5) (4) (3) (2)(1) i = 2 1234 7 8 (6) (5) (4) (3) (2)(1) i = 1 1234 8 (7) (6) (5) (4) (3) (2)(1) 至此，数据已经变成有序. 实现123456789101112131415161718192021222324252627282930313233//在有n个节点的堆中调整第k个节点void HeapShift(int array[], int n, int k)&#123; while(k * 2 + 1 &lt; n) //为分支节点(有孩子) &#123; int child = k * 2 + 1; //左右孩子的最小值的下标，默认为左孩子的下标 if(child + 1 &lt; n &amp;&amp; array[child + 1] &lt; array[child]) //有右孩子，且比左孩子小 &#123; child++; //更新左右孩子的最小值的下标为右孩子的下标 &#125; if(array[child] &gt; array[k]) //左右孩子的最小值比父大(调整完毕) &#123; return; //结束 &#125; swap(array[child], array[k]); //交换 k = child; //调整下一个 &#125;&#125;void Sort(int array[], int n)&#123; //建堆：从下至上依次调整分支节点 for(int i = n / 2 - 1; i &gt;= 0; i--) &#123; HeapShift(array, n, i); &#125; //排序(出堆)：首尾交换，调整根节点 for(int i = n - 1; i &gt; 0; i--) &#123; swap(array[0], array[i]); HeapShift(array, i, 0); &#125;&#125; END 堆排序理解起来可能有点困难，需要你多用数据模拟几次. 接下来还有桶、希尔排序等.","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-排序-快速","slug":"算法-排序-快速","date":"2021-07-17T07:20:25.000Z","updated":"2021-07-18T11:40:38.603Z","comments":true,"path":"2021/07/17/算法-排序-快速/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E5%BF%AB%E9%80%9F/","excerpt":"算法-排序4 快速排序","text":"算法-排序4 快速排序 特点 不稳定 平均性能高 简介 快速排序，顾名思义，很快. STL库中的sort()函数用的就是快速排序. 演示 原始数据(8个)X 4 8 3 2 5 1 6基准值 X = 7 第一次处理6 4 8 3 2 5 1 Xi j 第二次处理6 4 X 3 2 5 1 8 i j 第三次处理6 4 1 3 2 5 X 8 i j 第四次处理6 4 1 3 2 5 X 8 ij 放回原位 6 4 1 3 2 5 7 8 演示解析 经过处理，数据变成了两部分。在a[i]左侧的是比它小的数字，右侧的是比它大的数字.我们再将左侧进行处理，右侧进行处理，以此递归，直到左侧下标大于右侧下标，最终数据将变得有序. 实现1234567891011121314151617181920212223242526272829303132333435363738int Part(int array[], int start, int end)&#123; int X = array[start]; while(start &lt; end) &#123; while(array[end] &gt; X &amp;&amp; start &lt; end) //越界检查 &#123; end--; //找到右侧第一个比参考值小的 &#125; if(start &lt; end) //越界检查 &#123; array[start] = array[end]; //交换 start++; &#125; while(array[start] &lt; X &amp;&amp; start &lt; end) //越界检查 &#123; start++; //找到左侧第一个比参考值大的 &#125; if(start &lt; end) //越界检查 &#123; array[end] = array[start]; //交换 end--; &#125; &#125; //循环结束：start == end array[start] = X; return start;&#125;void Sort(int array[], int start, int end)&#123; if(start &gt;= end) //越界检查 return; int part = Part(array, start, end); //分治 Sort(array, start, part - 1); //左半边 Sort(array, part + 1, end); //右半边&#125; END 快速排序是一种性能较高的排序. 递归可能有点难以理解，最好自己拿数据试一试.接下来还有快速、堆、桶排序等.","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-排序-插入","slug":"算法-排序-插入","date":"2021-07-17T05:20:02.000Z","updated":"2021-07-18T11:40:25.999Z","comments":true,"path":"2021/07/17/算法-排序-插入/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E6%8F%92%E5%85%A5/","excerpt":"算法-排序3 插入排序","text":"算法-排序3 插入排序 特点 简单 对少量数据性能较好 稳定 简介 插入排序，顾名思义，把待排序的数据插入到应该在的位置. 演示 原始数据(8个)7 4 8 3 2 5 1 6 第一次排序7 4 8 3 2 5 1 6 第二次排序4 7 8 3 2 5 1 6 第三次排序4 7 8 3 2 5 1 6 第四次排序3 4 7 8 2 5 1 6 第五次排序2 3 4 7 8 5 1 6 第六次排序2 3 4 5 7 8 1 6 第七次排序1 2 3 4 5 7 8 6 第八次排序1 2 3 4 5 6 7 8 演示解析 第 i 次排序，是将a[i]从 i 向前移动 j 个数字，直到a[j]小于a[i]。 实现12345678910void Sort(int array[], int n)&#123; for(int i = 0; i &lt; n; i++) &#123; int j; for(int j = i; j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1]; j--) //当a[j]大于a[j - i]且没越界 swap(array[j], array[j - 1]); //向后移动 array[j - 1] = array[i]; //填充空位 &#125;&#125; END 插入排序依旧是一中较为简单的排序，接下来还有快速、堆、桶排序等。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-排序-选择","slug":"算法-排序-选择","date":"2021-07-17T03:35:11.000Z","updated":"2021-07-18T11:40:34.233Z","comments":true,"path":"2021/07/17/算法-排序-选择/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/17/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E9%80%89%E6%8B%A9/","excerpt":"算法-排序2 选择排序","text":"算法-排序2 选择排序 特点 不稳定(你也许没听懂) 较简单(至少我认为) 简介 选择排序，顾名思义，选择一个数，放到相应的位置. 演示 原始数据(8个)7 4 8 3 2 5 1 6 第一次排序1 4 8 3 2 5 7 6 第二次排序1 2 8 3 4 5 7 6 第三次排序1 2 3 8 4 5 7 6 第四次排序1 2 3 4 8 5 7 6 第五次排序1 2 3 4 5 8 7 6 第六次排序1 2 3 4 5 6 7 8 演示解析 从数据变化中我们可以看出，每一次都选择了未排序的子序列中的最小值和当前要排序的值进行交换. 实现1234567891011121314151617181920int FindiMin(int array[], int n, int start) //找到array[start] ~ array[n - 1]中的最小值&#123; int imin = start; for(int i = start + 1; i &lt; n; i++) &#123; if(array[i] &lt; array[imin]) &#123; imin = i; &#125; &#125; return imin;&#125;void Sort(int array[], int n)&#123; for(int i = 0; i &lt; n; i++) &#123; int imin = FindiMin(array, n, i); swap(array[imin], array[i]); &#125;&#125; END 选择排序还是一种比较简单的排序方法，接下来还有插入、快速、堆、桶排序等.","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-排序-冒泡","slug":"算法-排序-冒泡","date":"2021-07-16T08:15:30.000Z","updated":"2021-07-18T12:31:48.978Z","comments":true,"path":"2021/07/16/算法-排序-冒泡/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/16/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1/","excerpt":"算法-排序前言 有人可能会说，STL库中不是有sort函数吗，为什么还有学排序呢？因为排序的基本算法还有很多功能，如快速排序的求第k小(大)的数、插入排序的一元多项式等等。 1 冒泡排序","text":"算法-排序前言 有人可能会说，STL库中不是有sort函数吗，为什么还有学排序呢？因为排序的基本算法还有很多功能，如快速排序的求第k小(大)的数、插入排序的一元多项式等等。 1 冒泡排序 特点 简单(至少我个人认为) 稳定(你也许没听懂) 简介 冒泡排序，顾名思义，小的数据像泡泡一样向上(前)浮(移动). 演示 原始数据(8个)7 4 8 3 2 5 1 6 第一次排序4 7 3 2 5 1 6 8 第二次排序4 3 2 5 1 6 7 8 第三次排序3 2 4 1 5 6 7 8 第四次排序2 3 1 4 5 6 7 8 第五次排序2 1 3 4 5 6 7 8 第六次排序1 2 3 4 5 6 7 8 演示解析 从数据变化中我们可以看出，小的数据一直再向前走，大的数据一直在向后走，就像泡泡一样，向上浮。 实现Version 1 基本版本12345678910111213void Sort(int array[], int num)&#123; for(int i = 0; i &lt; num; i++) //需要走num遍排序 &#123; for(int j = 0; j &lt; num - 1; j++) //从0比较到num-1 &#123; if(array[j] &gt; array[j + 1]) //和后面一个数比较 &#123; swap(array[j], array[j + 1]); //交换 &#125; &#125; &#125;&#125; 在这个版本中，我们可以看到需要走num遍排序，时间复杂度是O(num^2)。而像演示一样的情况中，后面两次其实是不用走到，所以我们就要一个判断，判断数据是否已经有序。 Version 2 改进版本123456789101112131415161718void Sort(int array[], int num)&#123; bool flag; for(int i = 0; i &lt; num; i++) &#123; flag = true; //是否有序 for(int j = 0; j &lt; num - 1; j++) &#123; if(array[j] &gt; array[j + 1]) //更小 &#123; swap(array[j], array[j + 1]); //交换 flag = false; //依旧无序 &#125; &#125; if(flag == true) //已经有序 break; //跳出循环 &#125;&#125; 有了有序特判，算法的性能有了小幅提高。 END 冒泡排序还是一种比较简单的排序方法，接下来还有选择、插入、快速、堆、桶排序等。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"第一篇博文","slug":"第一篇博文","date":"2021-07-14T13:03:05.000Z","updated":"2021-07-17T10:39:56.471Z","comments":true,"path":"2021/07/14/第一篇博文/","link":"","permalink":"https://blog.jerryzrf.cf/2021/07/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/","excerpt":"","text":"第一篇博文Hello WorldJerryZRF 的 Blog 的第一篇博文发布于 2021-7-14 21:05","categories":[{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%A5%E5%BF%97/"},{"name":"时刻","slug":"时刻","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%B6%E5%88%BB/"}]}],"categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/categories/Cpp/"},{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://blog.jerryzrf.cf/tags/Cpp/"},{"name":"算法","slug":"算法","permalink":"https://blog.jerryzrf.cf/tags/%E7%AE%97%E6%B3%95/"},{"name":"日志","slug":"日志","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%A5%E5%BF%97/"},{"name":"时刻","slug":"时刻","permalink":"https://blog.jerryzrf.cf/tags/%E6%97%B6%E5%88%BB/"}]}