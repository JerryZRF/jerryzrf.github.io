{"meta":{"title":"Blog","subtitle":"JerryZRF的Blog","description":"Never Give Up!","author":"JerryZRF","url":"https://jerryzrf.github.io","root":"/"},"pages":[{"title":"资源","date":"2021-07-14T11:57:57.000Z","updated":"2021-07-14T12:03:26.702Z","comments":false,"path":"resources/index.html","permalink":"https://jerryzrf.github.io/resources/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-14T11:57:55.000Z","updated":"2021-07-14T11:58:55.322Z","comments":false,"path":"about/index.html","permalink":"https://jerryzrf.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-14T11:57:53.000Z","updated":"2021-07-14T12:03:44.404Z","comments":false,"path":"categories/index.html","permalink":"https://jerryzrf.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-14T11:57:54.000Z","updated":"2021-07-14T12:03:13.302Z","comments":false,"path":"tags/index.html","permalink":"https://jerryzrf.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基本算法-排序","slug":"基本排序","date":"2021-07-16T08:15:30.000Z","updated":"2021-07-16T09:39:32.760Z","comments":true,"path":"2021/07/16/基本排序/","link":"","permalink":"https://jerryzrf.github.io/2021/07/16/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F/","excerpt":"","text":"基本算法-排序前言 有人可能会说，STL库中不是有sort函数吗，为什么还有学排序呢？ 因为排序的基本算法还有很多功能，如快速排序的求第k小(大)的数、插入排序的一元多项式等等。 1 冒泡排序特点： 简单(至少我个人认为) 稳定(你也许没听懂) 演示： 原始数据(8个)7 4 8 3 2 5 1 6 第一次排序4 7 3 2 5 1 6 8 第二次排序 4 3 2 5 1 6 7 8 第三次排序 3 2 4 1 5 6 7 8 第四次排序 2 3 1 4 5 6 7 8 第五次排序 2 1 3 4 5 6 7 8 第六次排序 1 2 3 4 5 6 7 8 解析： 从数据变化中我们可以看出，小的数据一直再向前走，大的数据一直在向后走，就像泡泡一样，向上浮 实现Version 1 基本版本12345678910111213void Sort(int array[], int num)&#123; for(int i = 0; i &lt; num; i++) //需要走num遍排序 &#123; for(int j = 0; j &lt; num - 1; j++) //从0比较到num-1 &#123; if(array[j] &gt; array[j + 1]) //和后面一个数比较 &#123; swap(array[j], array[j + 1]); //交换 &#125; &#125; &#125;&#125; 在这个版本中，我们可以看到需要走num遍排序，时间复杂度是O(num^2)。而像演示一样的情况中，后面两次其实是不用走到，所以我们就要一个判断，判断数据是否已经有序。 Version 2 改进版本123456789101112131415161718void Sort(int array[], int num)&#123; bool flag; for(int i = 0; i &lt; num; i++) &#123; flag = true; //是否有序 for(int j = 0; j &lt; num - 1; j++) &#123; if(array[j] &gt; array[j + 1]) &#123; swap(array[j], array[j + 1]); flag = false; &#125; &#125; if(flag == true) //已经有序 break; //跳出循环 &#125;&#125; 有了有序特判，算法的性能有了小幅提高 总结 冒泡排序还是一种比较简单的排序方法，接下来还有选择、插入、快速、堆、桶排序等","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://jerryzrf.github.io/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://jerryzrf.github.io/tags/Cpp/"}]},{"title":"第一篇博文","slug":"第一篇博文","date":"2021-07-14T13:03:05.000Z","updated":"2021-07-15T10:20:04.086Z","comments":true,"path":"2021/07/14/第一篇博文/","link":"","permalink":"https://jerryzrf.github.io/2021/07/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/","excerpt":"","text":"第一篇博文Hello WorldJerryZRF 的 Blog 的第一篇博文发布于 2021-7-14 21:05","categories":[{"name":"日志","slug":"日志","permalink":"https://jerryzrf.github.io/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"日志","slug":"日志","permalink":"https://jerryzrf.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"时刻","slug":"时刻","permalink":"https://jerryzrf.github.io/tags/%E6%97%B6%E5%88%BB/"}]}],"categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://jerryzrf.github.io/categories/Cpp/"},{"name":"日志","slug":"日志","permalink":"https://jerryzrf.github.io/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://jerryzrf.github.io/tags/Cpp/"},{"name":"日志","slug":"日志","permalink":"https://jerryzrf.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"时刻","slug":"时刻","permalink":"https://jerryzrf.github.io/tags/%E6%97%B6%E5%88%BB/"}]}